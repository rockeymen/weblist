<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ«æ—¥é¿éš¾æ‰€ - å•æˆ¿é—´å¸ƒç½®ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            /* èƒŒæ™¯æ”¹ä¸ºæ·±é»‘ï¼Œçªå‡ºæˆ¿é—´ */
            overflow: hidden;
            font-family: 'Courier New', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .top-bar {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 15px;
            pointer-events: auto;
            box-sizing: border-box;
        }

        .top-right-bar {
            position: absolute;
            top: 10px;
            right: 15px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        /* åœ¨PCç«¯ï¼Œå»ºé€ æ§åˆ¶æŒ‰é’®æ°´å¹³å±…ä¸­å¹¶ä¸é€€å‡ºå»ºé€ æŒ‰é’®åœ¨åŒä¸€è¡Œé«˜åº¦ */
        @media (min-width: 769px) {
            #build-controls {
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
            }
        }
        
        /* åœ¨ç§»åŠ¨ç«¯ï¼Œå»ºé€ æ§åˆ¶æŒ‰é’®æ¯”é€€å‡ºå»ºé€ æŒ‰é’®ä½ä¸€è¡Œ */
        @media (max-width: 768px) {
            #build-controls {
                width: 100%;
                margin-top: 50px;
                display: flex;
                justify-content: center;
            }
        }

        .zoom-controls {
            position: absolute;
            right: 15px;
            top: 70px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(52, 73, 94, 0.8);
            border: 2px solid #fff;
            color: #fff;
            border-radius: 50%;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .btn {
            border: 2px solid #fff;
            color: #fff;
            background: #555;
            padding: 8px 15px;
            border-radius: 6px;
            font-weight: bold;
            box-shadow: 0 4px 0 #333;
            cursor: pointer;
            text-shadow: 1px 1px 0 #000;
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #333;
        }

        .btn.disabled {
            border-color: #777;
            color: #777;
            background: #333;
            cursor: not-allowed;
        }

        #reset-btn {
            background: #c0392b;
            border-color: #e74c3c;
        }

        #build-mode-btn {
            background: #3498db;
            border-color: #2980b9;
        }

        #build-mode-btn.active {
            background: #f1c40f;
            border-color: #f39c12;
            color: #333;
        }

        #delete-room-btn {
            background: #e67e22;
            border-color: #d35400;
            display: none;
        }

        #delete-item-btn {
            background: #e67e22;
            border-color: #d35400;
            display: none;
        }

        #main-menu {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background: #34495e;
            border-top: 4px solid #7f8c8d;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
            overflow-x: auto;
            /* æ·»åŠ æ¨ªå‘æ»šåŠ¨ */
            overflow-y: hidden;
            /* éšè—çºµå‘æ»šåŠ¨ */
            -webkit-overflow-scrolling: touch;
            /* iOS å¹³æ»‘æ»šåŠ¨ */
            scrollbar-width: none;
            /* éšè—æ»šåŠ¨æ¡ - Firefox */
            /* ç¡®ä¿å†…å®¹å®½åº¦è¶…å‡ºå®¹å™¨å®½åº¦ */
            width: 100vw;
        }

        /* éšè—æ»šåŠ¨æ¡ - Chrome, Safari, Edge */
        #main-menu::-webkit-scrollbar {
            display: none;
        }

        /* æ·»åŠ ä¸€ä¸ªåŒ…è£…å™¨æ¥ç¡®ä¿å†…å®¹å®½åº¦ */
        #main-menu-wrapper {
            display: flex;
            width: max-content;
            /* å†…å®¹å®½åº¦ */
            height: 100%;
        }

        .cat-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #ecf0f1;
            font-size: 12px;
            opacity: 0.7;
            transition: 0.2s;
            padding: 10px 4px;
            min-width: 70px;
            /* å‡å°æœ€å°å®½åº¦ï¼Œç¼©çª„é—´è· */
            flex-shrink: 0;
            /* é˜²æ­¢æŒ‰é’®ç¼©å° */
        }

        .cat-btn.active {
            opacity: 1;
            transform: scale(1.1);
            color: #f1c40f;
        }

        .cat-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        #sub-menu {
            position: absolute;
            bottom: 74px;
            left: 0;
            right: 0;
            height: 140px;
            background: rgba(30, 30, 30, 0.95);
            display: none;
            align-items: flex-start;
            justify-content: flex-start;
            overflow-x: auto;
            overflow-y: hidden;
            flex-direction: row;
            padding: 10px;
            gap: 20px;
            pointer-events: auto;
            z-index: 10;
            transition: transform 0.2s ease;
            transform: translateY(100%);
        }

        #sub-menu.visible {
            display: flex;
            animation: slideUp 0.2s ease-out;
            transform: translateY(0);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0
            }

            to {
                transform: translateY(0);
                opacity: 1
            }
        }

        .items-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            align-items: flex-start;
            align-content: flex-start;
            max-height: 120px;
            overflow-y: auto;
        }

        .item-image-btn {
            position: relative;
            width: 80px;
            height: 80px;
            background: #34495e;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .item-image-btn:hover {
            background: #3498db;
            transform: scale(1.05);
        }

        .item-image-btn img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        #toast {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2c3e50;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: #34495e;
            border-radius: 10px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #27ae60;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* è‡ªå®šä¹‰ç¡®è®¤å¼¹çª— */
        #confirm-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(3px);
        }

        .modal-content {
            background: #2c3e50;
            border: 2px solid #fff;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            color: #fff;
            max-width: 85%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 10px 25px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }

        .btn-confirm {
            background: #e67e22;
            color: white;
        }

        .btn-cancel {
            background: #95a5a6;
            color: white;
        }

        /* åˆ‡æ¢å¼€å…³æ ·å¼ */
        .toggle-switch {
            display: flex;
            background: #34495e;
            border-radius: 20px;
            padding: 2px;
            border: 2px solid #fff;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .toggle-option {
            padding: 6px 16px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #bdc3c7;
            transition: all 0.3s ease;
        }

        .toggle-option.active {
            background: #f1c40f;
            color: #2c3e50;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .toggle-option:hover:not(.active) {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        /* ç§»åŠ¨è®¾å¤‡æ ·å¼ */
        @media (max-width: 768px) {
            .zoom-controls {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div id="loading-screen">
        <div>
            <h3>æ­£åœ¨åŠ è½½èµ„æº...</h3>
            <div class="loading-bar">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <div id="loading-text">0/0</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- è‡ªå®šä¹‰ç¡®è®¤å¼¹çª— -->
    <div id="confirm-modal">
        <div class="modal-content">
            <p id="modal-msg">ç¡®å®šæ‰§è¡Œæ­¤æ“ä½œå—ï¼Ÿ</p>
            <div class="modal-buttons">
                <button id="modal-cancel" class="modal-btn btn-cancel">å–æ¶ˆ</button>
                <button id="modal-confirm" class="modal-btn btn-confirm">ç¡®å®š</button>
            </div>
        </div>
    </div>


    <style>
        #passage-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2100;
        }

        #passage-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            background: #000;
            width: 240px;
            height: 160px;
            margin: 20px auto;
            border: 2px solid #555;
        }

        .p-cell {
            background: #222;
            cursor: pointer;
            position: relative;
        }

        .p-cell img {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

    <div id="ui-layer">
        <div class="top-bar">
            <button id="reset-btn" class="btn" onclick="event.stopPropagation(); resetGame()">â™» é‡å»º</button>
        </div>
        <div class="top-right-bar">
            <button id="delete-item-btn" class="btn" onclick="event.stopPropagation(); deleteSelectedItem()">ğŸ—‘ï¸
                åˆ é™¤</button>
            <button id="delete-room-btn" class="btn" onclick="event.stopPropagation(); deleteSelectedRoom()">ğŸ—‘ï¸
                åˆ é™¤</button>
            <button id="build-mode-btn" class="btn" onclick="event.stopPropagation(); toggleBuildMode()">ğŸ§±
                å»ºé€ æ¨¡å¼</button>
        </div>
        
        <!-- å°†build-controlsç§»å‡ºtop-right-barï¼Œå®ç°é¡µé¢å±…ä¸­ -->
        <div id="build-controls" style="display:none; pointer-events: auto;">
            <div class="toggle-switch">
                <div id="opt-room" class="toggle-option active"
                    onclick="event.stopPropagation(); setBuildType('room')">å»ºæˆ¿é—´</div>
                <div id="opt-passage" class="toggle-option"
                    onclick="event.stopPropagation(); setBuildType('passage')">å»ºé€šé“</div>
            </div>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomView(1.2)">+</button>
            <button class="zoom-btn" onclick="zoomView(0.8)">-</button>
        </div>
        <div id="toast">æç¤º</div>

        <div id="sub-menu"></div>

        <div id="main-menu">
            <div id="main-menu-wrapper">
                <div class="cat-btn" onclick="toggleCat('beds')">
                    <div class="cat-icon">ğŸ›ï¸</div>åºŠ
                </div>
                <div class="cat-btn" onclick="toggleCat('seating')">
                    <div class="cat-icon">ğŸª‘</div>æ¤…å­/æ²™å‘
                </div>
                <div class="cat-btn" onclick="toggleCat('tables')">
                    <div class="cat-icon">ğŸª‘</div>æ¡Œå­
                </div>
                <div class="cat-btn" onclick="toggleCat('appliances')">
                    <div class="cat-icon">ğŸ“º</div>å®¶ç”µ
                </div>
                <div class="cat-btn" onclick="toggleCat('lighting')">
                    <div class="cat-icon">ğŸ’¡</div>ç¯
                </div>
                <div class="cat-btn" onclick="toggleCat('decor')">
                    <div class="cat-icon">ğŸ–¼ï¸</div>è£…é¥°
                </div>
                <div class="cat-btn" onclick="toggleCat('bathroom')">
                    <div class="cat-icon">ğŸš¿</div>å«æµ´
                </div>
                <div class="cat-btn" onclick="toggleCat('chests')">
                    <div class="cat-icon">ğŸ“¦</div>ç®±å­
                </div>
                <div class="cat-btn" onclick="toggleCat('supplies')">
                    <div class="cat-icon">ğŸ§´</div>ç”¨å“
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- å›¾ç‰‡èµ„æºç®¡ç†å™¨ ---
        class ImageManager {
            constructor() {
                this.images = {};
                this.loadedCount = 0;
                this.totalCount = 0;
                this.onProgress = null;
                this.onComplete = null;
            }

            loadImages(imageMap) {
                this.totalCount = Object.keys(imageMap).length;
                this.loadedCount = 0;

                for (let [key, path] of Object.entries(imageMap)) {
                    const img = new Image();
                    img.onload = () => {
                        this.loadedCount++;
                        this.images[key] = img;
                        this.updateProgress();
                        if (this.loadedCount === this.totalCount && this.onComplete) {
                            this.onComplete();
                        }
                    };
                    img.onerror = () => {
                        console.error(`Failed to load image: ${path}`);
                        this.loadedCount++;
                        this.updateProgress();
                    };
                    img.src = path;
                }
            }

            updateProgress() {
                if (this.onProgress) this.onProgress(this.loadedCount, this.totalCount);
            }

            getImage(key) { return this.images[key] || null; }
        }

        const imageManager = new ImageManager();

        // --- åŠ¨æ€ç›®å½•ç”Ÿæˆ ---
        function generateDynamicCatalog() {
            const categoryDirs = {
                'beds': 'åºŠ', 'seating': 'æ¤…å­/æ²™å‘', 'tables': 'æ¡Œå­',
                'appliances': 'å®¶ç”µ', 'lighting': 'ç¯', 'decor': 'è£…é¥°',
                'bathroom': 'å«æµ´', 'chests': 'ç®±å­', 'supplies': 'ç”¨å“'
            };

            const newCatalog = {};
            const newImageMap = {};
            const newItemDefs = {};

            const availableImages = {
                'beds': ['bed_1.png', 'bed_2.png', 'bed_3.png', 'bed_4.png', 'bed_5.png', 'bed_6.png', 'bed_7.png', 'bed_8.png', 'bed_9.png', 'bed_14.png', 'bed_15.png', 'bed_16.png'],
                'chairs': ['chair_1.png', 'chair_2.png', 'chair_4.png', 'chair_6.png', 'chair_8.png', 'chair_9.png', 'chair_10.png', 'chair_12.png', 'chair_13.png', 'chair_14.png', 'chair_15.png', 'chair_16.png', 'chair_17.png', 'chair_18.png', 'chair_27.png', 'chair_28.png', 'chair_29.png'],
                'tables': ['table_2.png', 'table_3.png', 'table_4.png', 'table_5.png', 'table_8.png', 'table_9.png', 'table_10.png', 'table_11.png', 'table_12.png', 'table_13.png', 'table_15.png', 'table_17.png', 'table_18.png', 'table_20.png', 'table_21.png', 'table_27.png', 'table_28.png', 'table_29.png'],
                'appliances': ['appliance_1_f.png', 'appliance_2_f.png', 'appliance_3_f.png', 'appliance_4.png', 'appliance_5.png', 'appliance_6_f.png', 'appliance_7_f.png', 'appliance_8_f.png', 'appliance_9.png', 'appliance_10_f.png', 'appliance_11_f.png', 'appliance_12_f.png', 'appliance_13_f.png', 'appliance_14_f.png', 'appliance_15.png', 'appliance_16.png', 'appliance_17.png', 'appliance_18.png', 'appliance_19.png', 'appliance_20.png', 'appliance_25_f.png', 'appliance_26.png'],
                'lights': ['light_1_f.png', 'light_2.png', 'light_3_f.png', 'light_5_f.png', 'light_6.png', 'light_7_f.png', 'light_8_f.png', 'light_9_f.png', 'light_10_f.png', 'light_12.png', 'light_13_f.png', 'light_14_f.png', 'light_15_f.png', 'light_16_f.png', 'light_17_f.png', 'light_19_f.png', 'light_20_f.png', 'light_21_f.png', 'light_30.png', 'light_31_f.png'],
                'decorations': ['deco_1_f.png', 'deco_2_f.png', 'deco_3_f.png', 'deco_5_f.png', 'deco_7_f.png', 'deco_11_f.png', 'deco_12_f.png', 'deco_13_f.png', 'deco_14_f.png', 'deco_15_f.png', 'deco_16_f.png', 'deco_17_f.png', 'deco_18_f.png', 'deco_19_f.png', 'deco_20_f.png', 'deco_21_f.png', 'deco_22_f.png', 'deco_23.png', 'deco_24_f.png', 'deco_25_f.png', 'deco_26_f.png', 'deco_27_f.png', 'deco_34_f.png', 'deco_35_f.png'],
                'bathroom': ['bathroom_1.png', 'bathroom_2.png', 'bathroom_3.png', 'bathroom_4.png', 'bathroom_5.png'],
                'chests': ['chest_1.png', 'chest_2.png', 'chest_3.png', 'chest_4.png'],
                'supplies': ['supply_1_f.png', 'supply_2_f.png', 'supply_3_f.png', 'supply_4_f.png', 'supply_5_f.png', 'supply_6.png']
            };

            for (let [categoryKey, categoryName] of Object.entries(categoryDirs)) {
                let imageDir = categoryKey;
                if (categoryKey === 'seating') imageDir = 'chairs';
                if (categoryKey === 'decor') imageDir = 'decorations';
                if (categoryKey === 'lighting') imageDir = 'lights';

                const images = availableImages[imageDir] || [];
                newCatalog[categoryKey] = {};

                images.forEach((imageFile, index) => {
                    const itemId = `${categoryKey}_${index + 1}`;
                    const itemName = imageFile.replace('.png', '').replace(/_/g, ' ');
                    const imagePath = `img/${imageDir}/${imageFile}`;
                    const subCategory = 'all'; // ç®€åŒ–ï¼Œç»Ÿä¸€æ”¾åˆ°ä¸€èµ·

                    if (!newCatalog[categoryKey][subCategory]) newCatalog[categoryKey][subCategory] = [];

                    // æ£€æŸ¥æ˜¯å¦æ˜¯_fç»“å°¾çš„æ–‡ä»¶ï¼ˆå¯ä»¥æ”¾ç½®åœ¨å…¶ä»–å®¶å…·ä¸Šæ–¹çš„è£…é¥°å“ï¼‰
                    const isForegroundItem = imageFile.endsWith('_f.png');

                    // å®šä¹‰ç‰©å“å±æ€§ï¼šè¿™é‡Œä¸è®¾å®šå…·ä½“çš„å®½é«˜ï¼Œå› ä¸ºä¼šä½¿ç”¨å›¾ç‰‡åŸå§‹æ¯”ä¾‹
                    let itemProps = {
                        id: itemId,
                        name: itemName,
                        imageKey: itemId,
                        type: isForegroundItem ? 'foreground' : ((categoryKey === 'lighting' || categoryKey === 'decor') ? 'mixed' : 'floor') // å‰æ™¯ç‰©å“ç±»å‹
                    };

                    // ç»™ä¸åŒåˆ†ç±»é¢„è®¾ä¸€äº›æ·±åº¦/ç¢°æ’ä½“ç§¯åŸºå‡†ï¼Œä½†ä¸»è¦ä¾èµ–å›¾ç‰‡
                    switch (categoryKey) {
                        case 'beds': itemProps.depthFactor = 0.8; break; // åºŠæ¯”è¾ƒæ·±
                        default: itemProps.depthFactor = 0.5; break;
                    }

                    // å¦‚æœæ˜¯å‰æ™¯ç‰©å“ï¼Œè®¾ç½®ç‰¹æ®Šå±æ€§
                    if (isForegroundItem) {
                        itemProps.isForeground = true;
                        itemProps.depthFactor = 0.1; // å‰æ™¯ç‰©å“æ·±åº¦è¾ƒå°
                    }

                    newCatalog[categoryKey][subCategory].push(itemProps);
                    newImageMap[itemId] = imagePath;
                    newItemDefs[itemId] = itemProps;
                });
            }
            return { catalog: newCatalog, imageMap: newImageMap, itemDefs: newItemDefs };
        }

        const { catalog, imageMap, itemDefs } = generateDynamicCatalog();

        // --- æ¸¸æˆå¼•æ“ ---        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // æ¸¸æˆçŠ¶æ€
        let gameData = {
            items: [],
            rooms: { "0,0": true } // ä½¿ç”¨ç½‘æ ¼åæ ‡ä½œä¸º Key
        };

        let roomRect = { w: 0, h: 0 }; // æˆ¿é—´çš„é€»è¾‘å¤§å°ï¼ˆç­‰äºèƒŒæ™¯å›¾åŸå§‹å¤§å°ï¼‰

        // è§†å›¾çŠ¶æ€ (ç‰©ç†åƒç´ åˆ°é€»è¾‘åæ ‡çš„æ˜ å°„)
        let view = {
            x: 0, // å…¨å±€åç§» X
            y: 0, // å…¨å±€åç§» Y
            zoom: 1.0, // ç”¨æˆ·ç¼©æ”¾æ¯”
            baseScale: 1.0, // åˆå§‹å¡«æ»¡å±å¹•çš„ç¼©æ”¾æ¯”
        };

        let preBuildView = null; // Store view state before entering build mode
        let hasTouched = false; // æ ‡è®°æ˜¯å¦å‘ç”Ÿäº†è§¦æ‘¸ç§»åŠ¨ï¼Œç”¨äºåŒºåˆ†ç‚¹å‡»å’Œæ‹–åŠ¨/ç¼©æ”¾
        let isTouchEvent = false; // æ ‡è®°å½“å‰äº‹ä»¶æ˜¯å¦ä¸ºè§¦æ‘¸äº‹ä»¶
        let touchStartPos = null; // è®°å½•è§¦æ‘¸å¼€å§‹çš„ä½ç½®
        let mouseStartPos = null; // è®°å½•é¼ æ ‡å¼€å§‹çš„ä½ç½®
        let startPanPos = null; // è®°å½•å¼€å§‹å¹³ç§»çš„ä½ç½®
        const DRAG_THRESHOLD = 5; // æ‹–åŠ¨é˜ˆå€¼ï¼Œå•ä½ï¼šåƒç´ 

        let isBuildMode = false;
        let buildType = 'room'; // 'room' | 'passage'
        let selectedRoomCoord = null; // å»ºé€ æ¨¡å¼ä¸‹é€‰ä¸­çš„æˆ¿é—´åæ ‡ "x,y"
        let isEditingPassage = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨ç¼–è¾‘é€šé“

        // äº¤äº’çŠ¶æ€
        let selectedItem = null;
        let isDragging = false;
        let isPanning = false; // æ‹–æ‹½èƒŒæ™¯å¹³ç§»è§†å›¾
        let dragOffset = { x: 0, y: 0 };
        let lastPanPos = { x: 0, y: 0 };

        // ç§»åŠ¨ç«¯ç¼©æ”¾
        let lastTouchDistance = 0;

        // --- åˆå§‹åŒ–æµç¨‹ ---
        function updateLoadingProgress(loaded, total) {
            const progress = (loaded / total) * 100;
            document.getElementById('loading-progress').style.width = progress + '%';
            document.getElementById('loading-text').textContent = `${loaded}/${total}`;
            if (loaded === total) {
                setTimeout(() => {
                    document.getElementById('loading-screen').style.display = 'none';
                    loadBackgroundAndStart();
                }, 500);
            }
        }

        imageManager.onProgress = updateLoadingProgress;
        imageManager.onComplete = () => console.log('Furniture loaded!');
        imageManager.loadImages(imageMap);

        let passageHImg = null;
        let passageVImg = null;
        let roomPassageImg = null;

        function loadBackgroundAndStart() {
            let loaded = 0;
            const total = 5; // Expected 5 images
            const onLoaded = () => {
                loaded++;
                if (loaded === total) {
                    // Start only after all critical resources are loaded
                    roomRect.w = roomImg.naturalWidth;
                    roomRect.h = roomImg.naturalHeight;
                    init();
                }
            };
            const onError = (src) => {
                console.error("Critical asset missing: " + src);
                alert("æ— æ³•åŠ è½½æ ¸å¿ƒèµ„æº: " + src);
            };

            const ts = Date.now() + 1; // Force new timestamp
            roomImg = new Image(); roomImg.onload = onLoaded; roomImg.onerror = () => onError(roomImg.src);
            roomImg.src = 'img/background/room.png?v=' + ts;

            roomBlankImg = new Image(); roomBlankImg.onload = onLoaded; roomBlankImg.onerror = () => onError(roomBlankImg.src);
            roomBlankImg.src = 'img/background/room_blank.png?v=' + ts;

            passageHImg = new Image(); passageHImg.onload = onLoaded; passageHImg.onerror = () => onError('img/background/passage_v.png');
            passageHImg.src = 'img/background/passage_h.png?v=' + ts;

            passageVImg = new Image(); passageVImg.onload = onLoaded; passageVImg.onerror = () => onError('img/background/passage_v.png');
            passageVImg.src = 'img/background/passage_v.png?v=' + ts;

            roomPassageImg = new Image(); roomPassageImg.onload = onLoaded; roomPassageImg.onerror = () => onError('img/background/room_passage.png');
            roomPassageImg.src = 'img/background/room_passage.png?v=' + ts;
        }

        function init() {
            load();
            resize();

            // åˆå§‹ä½ç½®ï¼šå°†ç¬¬ä¸€ä¸ªæˆ¿é—´å±…ä¸­
            view.x = (canvas.width / 2) - (roomRect.w * view.baseScale / 2);
            view.y = (canvas.height / 2) - (roomRect.h * view.baseScale / 2);

            loop();
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // è®¡ç®—åˆå§‹ç¼©æ”¾æ¯”ä¾‹ï¼šå›ºå®šä¸º0.2å€
            if (roomRect.w > 0) {
                view.baseScale = 0.2;
            }
        }

        function spawnItem(id) {
            const def = itemDefs[id];
            // æ”¾ç½®åœ¨é¡µé¢ä¸­å¿ƒ
            const finalScale = view.baseScale * view.zoom;
            // è®¡ç®—å±å¹•ä¸­å¿ƒå¯¹åº”çš„é€»è¾‘åæ ‡
            const centerX = (canvas.width / 2 - view.x) / finalScale;
            const centerY = (canvas.height / 2 - view.y) / finalScale;
            
            const newItem = {
                id: Date.now(),
                tid: id,
                x: centerX, // é€»è¾‘åæ ‡ X
                y: centerY, // é€»è¾‘åæ ‡ Y
            };

            // å°è¯•è·å–å›¾ç‰‡å°ºå¯¸æ¥ä¿®æ­£åˆå§‹ä½ç½®ï¼ˆå±…ä¸­ï¼‰
            const img = imageManager.getImage(def.imageKey);
            if (img) {
                newItem.x -= img.naturalWidth / 2;
                newItem.y -= img.naturalHeight / 2;
            }

            gameData.items.push(newItem);
            selectedItem = newItem;
            isDragging = false; // ç”Ÿæˆåä¸ç«‹å³æ‹–æ‹½ï¼Œé¿å…é£èµ°
            save();
            showToast("å·²æ·»åŠ : " + def.name);
            closeMenu();
        }

        function loop() {
            // æ¸…å±
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!roomImg || !roomBlankImg) return;

            ctx.save();
            // åº”ç”¨è§†å›¾å˜æ¢ï¼šå¹³ç§» -> ç¼©æ”¾
            ctx.translate(view.x, view.y);
            const finalScale = view.baseScale * view.zoom;
            ctx.scale(finalScale, finalScale);

            // 1. ç»˜åˆ¶æ‰€æœ‰æˆ¿é—´èƒŒæ™¯
            for (let coord in gameData.rooms) {
                const [rx, ry] = coord.split(',').map(Number);

                // æ£€æŸ¥ä¸Šæ–¹æ˜¯å¦æœ‰æˆ¿é—´
                const aboveKey = `${rx},${ry - 1}`;
                const hasAbove = !!gameData.rooms[aboveKey];

                const roomData = gameData.rooms[coord];
                const isPassage = roomData && roomData.type === 'passage';

                if (!isPassage) {
                    // æ™®é€šæˆ¿é—´
                    // é€»è¾‘ï¼šå¦‚æœä¸Šæ–¹å¯¹åº”ä½ç½®æœ‰æ™®é€šæˆ¿é—´ï¼Œç”¨ room_blank (æ— é¡¶); å¦åˆ™ç”¨ room (æœ‰é¡¶)
                    // å¦‚æœä¸Šæ–¹æ˜¯é€šé“ï¼Œä¹Ÿè§†ä¸º"æœ‰é¡¶"ï¼Œä½†ä¼šé¢å¤–ç»˜åˆ¶è¿æ¥
                    const aboveRoom = gameData.rooms[aboveKey];
                    const isAboveRegularRoom = aboveRoom && (!aboveRoom.type || aboveRoom.type === 'room');

                    const img = isAboveRegularRoom ? roomBlankImg : roomImg;
                    ctx.drawImage(img, rx * roomRect.w, ry * roomRect.h);

                    // å¦‚æœä¸Šæ–¹æ˜¯é€šé“ï¼Œç»˜åˆ¶è¿æ¥
                    if (aboveRoom && aboveRoom.type === 'passage' && aboveRoom.layout) {
                        const cellW = roomRect.w / 3;
                        const botRow = aboveRoom.layout[2]; // é€šé“åº•è¡Œ
                        for (let c = 0; c < 3; c++) {
                            if (botRow[c] === 1) {
                                // Don't scale, use original size, aligned top
                                ctx.drawImage(roomPassageImg, rx * roomRect.w + c * cellW, ry * roomRect.h);
                            }
                        }
                    }
                } else {
                    // é€šé“æˆ¿é—´ - ç»˜åˆ¶ 3x3
                    const cellW = roomRect.w / 3;
                    const cellH = roomRect.h / 3;
                    const layout = roomData.layout || [[0, 0, 0], [0, 0, 0], [0, 0, 0]]; // 3x3 array

                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            if (layout[r][c] === 1) {
                                let isAboveFilled = false;
                                if (r > 0) {
                                    if (layout[r - 1][c] === 1) isAboveFilled = true;
                                } else {
                                    // r=0, æ£€æŸ¥ä¸Šæ–¹é‚»å±…
                                    // é€»è¾‘ï¼šå¦‚æœä¸Šæ–¹å¯¹åº”ä½ç½®æœ‰ä¸œè¥¿ï¼ˆæ— è®ºæ˜¯é€šé“è¿˜æ˜¯æ™®é€šæˆ¿é—´ï¼‰ï¼Œå°±è®¤ä¸ºæ˜¯ vertically connected
                                    const aboveRoom = gameData.rooms[aboveKey];
                                    if (aboveRoom) {
                                        if (aboveRoom.type === 'passage') {
                                            // å¯¹æ–¹æ˜¯é€šé“ï¼Œæ£€æŸ¥å¯¹æ–¹åº•è¾¹
                                            if (aboveRoom.layout && aboveRoom.layout[2][c] === 1) isAboveFilled = true;
                                        } else {
                                            // å¯¹æ–¹æ˜¯æ™®é€šæˆ¿é—´ï¼Œè§†ä¸ºå¡«æ»¡
                                            isAboveFilled = true;
                                        }
                                    }
                                }

                                const pImg = isAboveFilled ? passageVImg : passageHImg;
                                ctx.drawImage(pImg,
                                    rx * roomRect.w + c * cellW,
                                    ry * roomRect.h + r * cellH,
                                    cellW, cellH
                                );
                            }
                        }
                    }
                }

                // å¦‚æœæ˜¯é€‰ä¸­çš„æˆ¿é—´ï¼Œç»˜åˆ¶é«˜äº®æ¡†
                if (isBuildMode && selectedRoomCoord === coord) {
                    ctx.save();
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 2 / finalScale;
                    ctx.strokeRect(rx * roomRect.w + 5, ry * roomRect.h + 5, roomRect.w - 10, roomRect.h - 10);
                    ctx.restore();
                }
            }

            // 2. å¦‚æœæ˜¯å»ºé€ æ¨¡å¼ï¼Œç»˜åˆ¶ "+" å·
            if (isBuildMode) {
                drawBuildIcons();
            }

            // 3. ç»˜åˆ¶ç‰©å“
            const foregroundItems = [];
            const regularItems = [];

            gameData.items.forEach(item => {
                const def = itemDefs[item.tid];
                if (def.isForeground) {
                    foregroundItems.push(item);
                } else {
                    regularItems.push(item);
                }
            });

            // æ’åºé€»è¾‘ (å…¨å±€ Y åæ ‡)
            regularItems.sort((a, b) => {
                const imgA = imageManager.getImage(itemDefs[a.tid].imageKey);
                const imgB = imageManager.getImage(itemDefs[b.tid].imageKey);
                const hA = imgA ? imgA.naturalHeight : 0;
                const hB = imgB ? imgB.naturalHeight : 0;
                return (a.y + hA) - (b.y + hB);
            });

            const sortedItems = [...regularItems, ...foregroundItems];

            sortedItems.forEach(item => {
                const def = itemDefs[item.tid];
                const img = imageManager.getImage(def.imageKey);

                if (img) {
                    const w = img.naturalWidth;
                    const h = img.naturalHeight;

                    ctx.drawImage(img, item.x, item.y);

                    // ç»˜åˆ¶é€‰ä¸­æ¡†ï¼ˆé»„è‰²å®çº¿ï¼‰
                    if (selectedItem === item) {
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2 / finalScale;
                        ctx.strokeRect(item.x, item.y, w, h);
                    }
                }
            });

            ctx.restore();
            requestAnimationFrame(loop);
        }

        function drawBuildIcons() {
            const potentialRooms = new Set();
            const neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]];

            for (let coord in gameData.rooms) {
                const [rx, ry] = coord.split(',').map(Number);
                neighbors.forEach(([dx, dy]) => {
                    const nx = rx + dx, ny = ry + dy;
                    const nKey = `${nx},${ny}`;
                    if (!gameData.rooms[nKey]) {
                        potentialRooms.add(nKey);
                    }
                });
            }

            potentialRooms.forEach(key => {
                const [rx, ry] = key.split(',').map(Number);
                const bx = rx * roomRect.w;
                const by = ry * roomRect.h;

                // ç»˜åˆ¶åŠé€æ˜å ä½çŸ©å½¢
                ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
                ctx.fillRect(bx + 10, by + 10, roomRect.w - 20, roomRect.h - 20);

                // ç»˜åˆ¶ "+"
                if (buildType === 'passage') {
                    ctx.fillStyle = "#3498db"; // Blue
                } else {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                }
                ctx.font = `${roomRect.h * 0.3}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("+", bx + roomRect.w / 2, by + roomRect.h / 2);
            });
        }

        // --- è¾“å…¥äº‹ä»¶ ---

        // è·å–ç›¸å¯¹äºé€»è¾‘åæ ‡ç³»ï¼ˆç‰©ç†ä¸–ç•Œï¼‰çš„é¼ æ ‡ä½ç½®
        function getLogicalPos(e) {
            const r = canvas.getBoundingClientRect();
            const clientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;

            // å±å¹•åæ ‡ -> ç”»å¸ƒåæ ‡ -> å‡å»åç§» -> é™¤ä»¥ç¼©æ”¾ -> é€»è¾‘åæ ‡
            const finalScale = view.baseScale * view.zoom;
            const x = (clientX - r.left - view.x) / finalScale;
            const y = (clientY - r.top - view.y) / finalScale;
            return { x, y };
        }

        function handleStart(e) {
            // æ ‡è®°å½“å‰äº‹ä»¶ç±»å‹
            isTouchEvent = e.touches && e.touches.length > 0;
            
            // åªæœ‰è§¦æ‘¸äº‹ä»¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé¿å…å½±å“PCé¼ æ ‡äº‹ä»¶
            if (isTouchEvent) {
                e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢è§¦æ‘¸äº‹ä»¶è§¦å‘é¼ æ ‡äº‹ä»¶
            }
            
            if (e.target !== canvas) return;
            hasTouched = false; // é‡ç½®è§¦æ‘¸ç§»åŠ¨æ ‡å¿—
            
            // è®°å½•åˆå§‹ä½ç½®
            const p = getLogicalPos(e);
            if (isTouchEvent) {
                touchStartPos = p;
            } else {
                mouseStartPos = p;
            }
            
            // è®°å½•å±å¹•åæ ‡ç”¨äºåˆ¤æ–­æ‹–æ‹½è·ç¦»
            const clientX = isTouchEvent ? e.touches[0].clientX : e.clientX;
            const clientY = isTouchEvent ? e.touches[0].clientY : e.clientY;
            lastPanPos = { x: clientX, y: clientY };

            // 1. æ£€æµ‹ç‰©å“ç‚¹å‡»ï¼Œå‡†å¤‡æ‹–åŠ¨
            for (let i = gameData.items.length - 1; i >= 0; i--) {
                const item = gameData.items[i];
                const def = itemDefs[item.tid];
                const img = imageManager.getImage(def.imageKey);

                if (img) {
                    const w = img.naturalWidth;
                    const h = img.naturalHeight;

                    if (p.x >= item.x && p.x <= item.x + w &&
                        p.y >= item.y && p.y <= item.y + h) {

                        selectedItem = item;
                        dragOffset.x = p.x - item.x;
                        dragOffset.y = p.y - item.y;
                        isDragging = true; // è®¾ç½®æ‹–æ‹½çŠ¶æ€
                        return;
                    }
                }
            }

            // 2. ç‚¹å‡»ç©ºç™½ï¼šå‡†å¤‡å¹³ç§»
            selectedItem = null;
            if (!isBuildMode) {
                document.getElementById('delete-item-btn').style.display = 'none';
            }
            
            // å¤„ç†åŒæŒ‡ç¼©æ”¾åˆå§‹è·ç¦»
            if (isTouchEvent && e.touches.length === 2) {
                lastTouchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }

        function handleMove(e) {
            // åªæœ‰è§¦æ‘¸äº‹ä»¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé¿å…å½±å“PCé¼ æ ‡äº‹ä»¶
            if (isTouchEvent) {
                e.preventDefault();
                hasTouched = true;
            }
            
            const p = getLogicalPos(e);

            // 1. æ‹–æ‹½ç‰©å“
            if (selectedItem && (isDragging || isTouchEvent)) {
                isDragging = true;
                selectedItem.x = p.x - dragOffset.x;
                selectedItem.y = p.y - dragOffset.y;
                return;
            }

            // 2. åŒæŒ‡ç¼©æ”¾
            if (isTouchEvent && e.touches && e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                if (lastTouchDistance > 0) {
                    const ratio = dist / lastTouchDistance;
                    zoomView(ratio, true); // true è¡¨ç¤ºæ˜¯ç›¸å¯¹æ¯”ä¾‹
                }
                lastTouchDistance = dist;
                return;
            }

            // 3. è§†å›¾å¹³ç§»
            const clientX = isTouchEvent && e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
            const clientY = isTouchEvent && e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;
            
            // è®¡ç®—ç§»åŠ¨è·ç¦»
            let distance = 0;
            let startX = 0;
            let startY = 0;
            
            if (isTouchEvent && touchStartPos) {
                startX = touchStartPos.x;
                startY = touchStartPos.y;
                distance = Math.sqrt((p.x - startX) * (p.x - startX) + (p.y - startY) * (p.y - startY));
            } else if (!isTouchEvent && mouseStartPos) {
                startX = mouseStartPos.x;
                startY = mouseStartPos.y;
                distance = Math.sqrt((e.clientX - startX) * (e.clientX - startX) + (e.clientY - startY) * (e.clientY - startY));
            }
            
            if (isPanning || distance > DRAG_THRESHOLD) {
                // åªæœ‰å½“å·²ç»åœ¨å¹³ç§»çŠ¶æ€æˆ–ç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼æ—¶æ‰è¿›è¡Œå¹³ç§»
                if (!isPanning) {
                    isPanning = true;
                }
                
                view.x += clientX - lastPanPos.x;
                view.y += clientY - lastPanPos.y;
                lastPanPos = { x: clientX, y: clientY };
            }
        }

        function handleEnd(e) {
            // åªæœ‰è§¦æ‘¸äº‹ä»¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé¿å…å½±å“PCé¼ æ ‡äº‹ä»¶
            if (isTouchEvent) {
                e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢è§¦æ‘¸äº‹ä»¶è§¦å‘é¼ æ ‡äº‹ä»¶
            }
            
            if (isDragging) save();
            
            // å¤„ç†è§¦æ‘¸äº‹ä»¶ç‚¹å‡»
            if (isTouchEvent && !hasTouched && touchStartPos) {
                // 1. å¦‚æœæ˜¯å»ºé€ æ¨¡å¼ï¼Œä¼˜å…ˆæ£€æµ‹äº¤äº’
                if (isBuildMode) {
                    if (checkBuildClick(touchStartPos)) {
                        isDragging = false;
                        isPanning = false;
                        lastTouchDistance = 0;
                        touchStartPos = null;
                        mouseStartPos = null;
                        isTouchEvent = false;
                        return;
                    }

                    // æ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†ç°æœ‰æˆ¿é—´è¿›è¡Œé€‰ä¸­æˆ–ç¼–è¾‘
                    const rx = Math.floor(touchStartPos.x / roomRect.w);
                    const ry = Math.floor(touchStartPos.y / roomRect.h);
                    const coord = `${rx},${ry}`;

                    const targetRoom = gameData.rooms[coord];
                    if (targetRoom) {
                        selectedRoomCoord = coord;
                        selectedItem = null; // å–æ¶ˆå®¶å…·é€‰ä¸­
                        updateDeleteButtonState();
                        
                        // Logic: For passage, enter edit mode directly on first click
                        if (targetRoom.type === 'passage') {
                            // å¦‚æœå·²ç»åœ¨ç¼–è¾‘æ¨¡å¼ï¼Œåˆ™åˆ‡æ¢é€šé“æ ¼å­çŠ¶æ€
                            if (isEditingPassage) {
                                // Edit passage grid
                                const lx = touchStartPos.x - rx * roomRect.w;
                                const ly = touchStartPos.y - ry * roomRect.h;
                                const c = Math.floor(lx / (roomRect.w / 3));
                                const r = Math.floor(ly / (roomRect.h / 3));

                                if (r >= 0 && r < 3 && c >= 0 && c < 3) {
                                    if (!targetRoom.layout) targetRoom.layout = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
                                    targetRoom.layout[r][c] = targetRoom.layout[r][c] ? 0 : 1;
                                    save(); // Auto save on edit
                                }
                            } else {
                                // å¦‚æœä¸åœ¨ç¼–è¾‘æ¨¡å¼ï¼Œåˆ™è¿›å…¥ç¼–è¾‘æ¨¡å¼
                                isEditingPassage = true;
                                showToast("ç°åœ¨å¯ä»¥ç‚¹å‡»é€šé“æ ¼å­æ¥ä¿®æ”¹é€šé“å½¢çŠ¶");
                            }
                        } else {
                            // æ™®é€šæˆ¿é—´ï¼Œä¿æŒåŸæœ‰é€»è¾‘
                            isEditingPassage = false;
                            showToast(`å·²é€‰ä¸­: ${coord}`);
                        }
                        isDragging = false;
                        isPanning = false;
                        lastTouchDistance = 0;
                        touchStartPos = null;
                        mouseStartPos = null;
                        isTouchEvent = false;
                        return;
                    }
                }

                // 2. å¦‚æœé€‰ä¸­äº†å®¶å…·ï¼Œæ˜¾ç¤ºåˆ é™¤æŒ‰é’®
                if (selectedItem && !isBuildMode) {
                    document.getElementById('delete-item-btn').style.display = 'block';
                }

                // 3. å¦‚æœæ˜¯å»ºé€ æ¨¡å¼ä¸”ç‚¹å‡»ç©ºç™½ï¼Œå–æ¶ˆé€‰ä¸­
                if (isBuildMode && !selectedItem) {
                    selectedRoomCoord = null;
                    isEditingPassage = false; // é‡ç½®ç¼–è¾‘æ¨¡å¼çŠ¶æ€
                    updateDeleteButtonState();
                }
            } 
            // å¤„ç†é¼ æ ‡äº‹ä»¶ç‚¹å‡»
            else if (!isTouchEvent && !isDragging && !isPanning && mouseStartPos) {
                // 1. å¦‚æœæ˜¯å»ºé€ æ¨¡å¼ï¼Œä¼˜å…ˆæ£€æµ‹äº¤äº’
                if (isBuildMode) {
                    if (checkBuildClick(mouseStartPos)) {
                        isDragging = false;
                        isPanning = false;
                        lastTouchDistance = 0;
                        touchStartPos = null;
                        mouseStartPos = null;
                        return;
                    }

                    // æ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†ç°æœ‰æˆ¿é—´è¿›è¡Œé€‰ä¸­æˆ–ç¼–è¾‘
                    const rx = Math.floor(mouseStartPos.x / roomRect.w);
                    const ry = Math.floor(mouseStartPos.y / roomRect.h);
                    const coord = `${rx},${ry}`;

                    const targetRoom = gameData.rooms[coord];
                    if (targetRoom) {
                        selectedRoomCoord = coord;
                        selectedItem = null; // å–æ¶ˆå®¶å…·é€‰ä¸­
                        updateDeleteButtonState();
                        
                        // Logic: For passage, enter edit mode directly on first click
                        if (targetRoom.type === 'passage') {
                            // å¦‚æœå·²ç»åœ¨ç¼–è¾‘æ¨¡å¼ï¼Œåˆ™åˆ‡æ¢é€šé“æ ¼å­çŠ¶æ€
                            if (isEditingPassage) {
                                // Edit passage grid
                                const lx = mouseStartPos.x - rx * roomRect.w;
                                const ly = mouseStartPos.y - ry * roomRect.h;
                                const c = Math.floor(lx / (roomRect.w / 3));
                                const r = Math.floor(ly / (roomRect.h / 3));

                                if (r >= 0 && r < 3 && c >= 0 && c < 3) {
                                    if (!targetRoom.layout) targetRoom.layout = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
                                    targetRoom.layout[r][c] = targetRoom.layout[r][c] ? 0 : 1;
                                    save(); // Auto save on edit
                                }
                            } else {
                                // å¦‚æœä¸åœ¨ç¼–è¾‘æ¨¡å¼ï¼Œåˆ™è¿›å…¥ç¼–è¾‘æ¨¡å¼
                                isEditingPassage = true;
                                showToast("ç°åœ¨å¯ä»¥ç‚¹å‡»é€šé“æ ¼å­æ¥ä¿®æ”¹é€šé“å½¢çŠ¶");
                            }
                        } else {
                            // æ™®é€šæˆ¿é—´ï¼Œä¿æŒåŸæœ‰é€»è¾‘
                            isEditingPassage = false;
                            showToast(`å·²é€‰ä¸­: ${coord}`);
                        }
                        isDragging = false;
                        isPanning = false;
                        lastTouchDistance = 0;
                        touchStartPos = null;
                        mouseStartPos = null;
                        return;
                    }
                }

                // 2. å¦‚æœé€‰ä¸­äº†å®¶å…·ï¼Œæ˜¾ç¤ºåˆ é™¤æŒ‰é’®
                if (selectedItem && !isBuildMode) {
                    document.getElementById('delete-item-btn').style.display = 'block';
                }

                // 3. å¦‚æœæ˜¯å»ºé€ æ¨¡å¼ä¸”ç‚¹å‡»ç©ºç™½ï¼Œå–æ¶ˆé€‰ä¸­
                if (isBuildMode && !selectedItem) {
                    selectedRoomCoord = null;
                    isEditingPassage = false; // é‡ç½®ç¼–è¾‘æ¨¡å¼çŠ¶æ€
                    updateDeleteButtonState();
                }
            }
            
            isDragging = false;
            isPanning = false;
            lastTouchDistance = 0;
            touchStartPos = null;
            mouseStartPos = null;
            hasTouched = false;
            isTouchEvent = false;
        }

        // --- æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ---
        function toggleBuildMode() {
            isBuildMode = !isBuildMode;
            const btn = document.getElementById('build-mode-btn');
            const delBtn = document.getElementById('delete-room-btn');
            const itemDelBtn = document.getElementById('delete-item-btn');
            const mainMenu = document.getElementById('main-menu');
            const subMenu = document.getElementById('sub-menu');

            if (isBuildMode) {
                btn.classList.add('active');
                btn.innerText = "é€€å‡ºå»ºé€ ";
                mainMenu.style.display = 'none';
                subMenu.style.display = 'none';
                itemDelBtn.style.display = 'none'; // å»ºé€ æ¨¡å¼ä¸æ˜¾ç¤ºå®¶å…·åˆ é™¤æŒ‰é’®ï¼ˆæ˜¾ç¤ºæˆ¿é—´åˆ é™¤ï¼‰
                delBtn.style.display = 'block';
            } else {
                btn.classList.remove('active');
                btn.innerText = "ğŸ§± å»ºé€ æ¨¡å¼";
                mainMenu.style.display = 'flex';
                // subMenu ä¿æŒåŸæœ‰ display: none é€»è¾‘ï¼Œç”± toggleCat æ§åˆ¶
                delBtn.style.display = 'none';
                selectedRoomCoord = null;
                isEditingPassage = false; // é‡ç½®ç¼–è¾‘æ¨¡å¼çŠ¶æ€
                updateDeleteButtonState();
            }

            showToast(isBuildMode ? "å·²è¿›å…¥å»ºé€ æ¨¡å¼" : "å·²é€€å‡ºå»ºé€ æ¨¡å¼");

            // è‡ªåŠ¨ç¼©æ”¾ä»¥ä¾¿è§‚å¯Ÿ
            if (isBuildMode) {
                fitAllRooms();
            }
        }

        function fitAllRooms() {
            const coords = Object.keys(gameData.rooms);
            if (coords.length === 0) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            coords.forEach(key => {
                const [rx, ry] = key.split(',').map(Number);
                minX = Math.min(minX, rx);
                maxX = Math.max(maxX, rx);
                minY = Math.min(minY, ry);
                maxY = Math.max(maxY, ry);
            });

            // Calculate Bounding Box dimensions in logic units
            // Add slight padding to logic range for better visual
            const totalW = (maxX - minX + 2.5) * roomRect.w; // +2.5 for generous padding
            const totalH = (maxY - minY + 2.5) * roomRect.h;

            // Center of BB
            const cx = ((minX + maxX) / 2 + 0.5) * roomRect.w;
            const cy = ((minY + maxY) / 2 + 0.5) * roomRect.h;

            const screenW = canvas.width;
            const screenH = canvas.height;

            const scaleX = screenW / totalW;
            const scaleY = screenH / totalH;
            // Target scaling factor (real pixels per logic pixel) matches finalScale
            // finalScale = view.baseScale * view.zoom;
            // So view.zoom = targetFinalScale / view.baseScale

            const targetFinalScale = Math.min(scaleX, scaleY);
            view.zoom = targetFinalScale / view.baseScale;

            // Recenter
            view.x = (screenW / 2) - (cx * targetFinalScale);
            view.y = (screenH / 2) - (cy * targetFinalScale);
        }

        function deleteSelectedRoom() {
            if (!selectedRoomCoord || !isBuildMode) {
                showToast("è¯·å…ˆåœ¨å»ºé€ æ¨¡å¼ä¸‹ç‚¹å‡»é€‰ä¸­ä¸€ä¸ªæˆ¿é—´");
                return;
            }
            if (selectedRoomCoord === "0,0") {
                showToast("åˆå§‹æˆ¿é—´ä¸å¯åˆ é™¤");
                return;
            }

            // æ£€æŸ¥æˆ¿é—´å†…æ˜¯å¦æœ‰å®¶å…·
            const [rx, ry] = selectedRoomCoord.split(',').map(Number);
            const xMin = rx * roomRect.w;
            const xMax = (rx + 1) * roomRect.w;
            const yMin = ry * roomRect.h;
            const yMax = (ry + 1) * roomRect.h;

            const hasItems = gameData.items.some(item => {
                const def = itemDefs[item.tid];
                if (!def) return false;
                const img = imageManager.getImage(def.imageKey);
                const cx = item.x + (img ? img.naturalWidth / 2 : 0);
                const cy = item.y + (img ? img.naturalHeight / 2 : 0);
                return (cx >= xMin && cx < xMax && cy >= yMin && cy < yMax);
            });

            const doDelete = () => {
                // 1. åˆ é™¤æˆ¿é—´
                delete gameData.rooms[selectedRoomCoord];

                // 2. åˆ é™¤è¯¥æˆ¿é—´å†…çš„å®¶å…·
                gameData.items = gameData.items.filter(item => {
                    const def = itemDefs[item.tid];
                    if (!def) return true;
                    const img = imageManager.getImage(def.imageKey);
                    const cx = item.x + (img ? img.naturalWidth / 2 : 0);
                    const cy = item.y + (img ? img.naturalHeight / 2 : 0);
                    return !(cx >= xMin && cx < xMax && cy >= yMin && cy < yMax);
                });

                selectedRoomCoord = null;
                updateDeleteButtonState();
                save();
                showToast("æˆ¿é—´å·²åˆ é™¤");
            };

            if (hasItems) {
                customConfirm(`ç¡®è®¤åˆ é™¤æˆ¿é—´ ${selectedRoomCoord} åŠå…¶å†…éƒ¨æ‰€æœ‰å®¶å…·å—ï¼Ÿ`, doDelete);
            } else {
                doDelete();
            }
        }

        function deleteSelectedItem() {
            if (!selectedItem) return;
            gameData.items = gameData.items.filter(it => it !== selectedItem);
            selectedItem = null;
            document.getElementById('delete-item-btn').style.display = 'none';
            save();
            showToast("å®¶å…·å·²åˆ é™¤");
        }

        function zoomView(scale, isRelative = false) {
            const oldZoom = view.zoom;
            if (isRelative) {
                view.zoom *= scale;
            } else {
                view.zoom *= scale;
            }
            view.zoom = Math.max(0.1, Math.min(view.zoom, 5.0));

            const zoomChange = view.zoom / oldZoom;
            // ç®€å•çš„å¯¹é½ï¼šé€šè¿‡å±å¹•ä¸­å¿ƒè¿›è¡Œç¼©æ”¾
            // é€»è¾‘æ˜¯ï¼šç¼©æ”¾å‰åï¼Œå±å¹•ä¸­å¿ƒçš„é€»è¾‘åæ ‡åº”è¯¥ä¿æŒä¸€è‡´
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            view.x = centerX - (centerX - view.x) * zoomChange;
            view.y = centerY - (centerY - view.y) * zoomChange;
        }

        function addRoom(key, type = 'room', extraData = null) {
            if (type === 'room') {
                gameData.rooms[key] = { type: 'room' };
            } else if (type === 'passage') {
                gameData.rooms[key] = { type: 'passage', layout: extraData };
            }
            save();
            showToast("å»ºé€ å®Œæˆ");
        }

        // --- å»ºé€ ç³»ç»Ÿ ---
        function setBuildType(type) {
            buildType = type;
            const optRoom = document.getElementById('opt-room');
            const optPassage = document.getElementById('opt-passage');

            if (type === 'room') {
                optRoom.classList.add('active');
                optPassage.classList.remove('active');
            } else {
                optRoom.classList.remove('active');
                optPassage.classList.add('active');
            }
        }

        function toggleBuildMode() {
            isBuildMode = !isBuildMode;
            const btn = document.getElementById('build-mode-btn');
            const buildControls = document.getElementById('build-controls');
            const delBtn = document.getElementById('delete-room-btn');
            const itemDelBtn = document.getElementById('delete-item-btn');
            const mainMenu = document.getElementById('main-menu');
            const subMenu = document.getElementById('sub-menu');

            if (isBuildMode) {
                // Determine previous view state
                preBuildView = { x: view.x, y: view.y, zoom: view.zoom };

                btn.classList.add('active');
                btn.innerText = "é€€å‡ºå»ºé€ ";
                mainMenu.style.display = 'none';
                subMenu.style.display = 'none';
                itemDelBtn.style.display = 'none';
                delBtn.style.display = 'block';
                buildControls.style.display = 'flex';
                // Reset to default
                setBuildType('room');

                // Auto fit
                fitAllRooms();
            } else {
                btn.classList.remove('active');
                btn.innerText = "ğŸ§± å»ºé€ æ¨¡å¼";
                mainMenu.style.display = 'flex';
                delBtn.style.display = 'none';
                buildControls.style.display = 'none';
                selectedRoomCoord = null;
                updateDeleteButtonState();

                // Restore previous view if available
                if (preBuildView) {
                    view.x = preBuildView.x;
                    view.y = preBuildView.y;
                    view.zoom = preBuildView.zoom;
                    preBuildView = null;
                }
            }
        }


        function checkBuildClick(p) {
            const neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]];
            const potentialRooms = [];

            for (let coord in gameData.rooms) {
                const [rx, ry] = coord.split(',').map(Number);
                neighbors.forEach(([dx, dy]) => {
                    const nx = rx + dx, ny = ry + dy;
                    const nKey = `${nx},${ny}`;
                    if (!gameData.rooms[nKey]) potentialRooms.push({ key: nKey, x: nx, y: ny });
                });
            }

            for (let r of potentialRooms) {
                const bx = r.x * roomRect.w;
                const by = r.y * roomRect.h;

                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è¯¥åŒºåŸŸ
                if (p.x >= bx && p.x <= bx + roomRect.w &&
                    p.y >= by && p.y <= by + roomRect.h) {

                    if (buildType === 'room') {
                        addRoom(r.key, 'room');
                    } else {
                        // é»˜è®¤åå­—æ˜Ÿ: ä¸­é—´è¡Œå…¨æ»¡ï¼Œä¸­é—´åˆ—å…¨æ»¡
                        const crossLayout = [
                            [0, 1, 0],
                            [1, 1, 1],
                            [0, 1, 0]
                        ];
                        addRoom(r.key, 'passage', crossLayout);
                    }
                    return true;
                }
            }
            return false;
        }

        function drawBuildIcons() {
            const potentialRooms = new Set();
            const neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1]];

            for (let coord in gameData.rooms) {
                const [rx, ry] = coord.split(',').map(Number);
                neighbors.forEach(([dx, dy]) => {
                    const nx = rx + dx, ny = ry + dy;
                    const nKey = `${nx},${ny}`;
                    if (!gameData.rooms[nKey]) {
                        potentialRooms.add(nKey);
                    }
                });
            }

            ctx.save();
            potentialRooms.forEach(key => {
                const [rx, ry] = key.split(',').map(Number);
                const bx = rx * roomRect.w;
                const by = ry * roomRect.h;

                // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯æŒ‡ç¤ºä½ç½®
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(bx + 4, by + 4, roomRect.w - 8, roomRect.h - 8);

                // ç»˜åˆ¶ "+"
                if (buildType === 'passage') {
                    ctx.fillStyle = "#3498db"; // Blue
                } else {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                }
                ctx.font = `${roomRect.h * 0.3}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("+", bx + roomRect.w / 2, by + roomRect.h / 2);
            });
            ctx.restore();
        }


        // --- UI & Helper ---
        let curCat = null;
        function toggleCat(cat) {
            const sub = document.getElementById('sub-menu');
            const btns = document.querySelectorAll('.cat-btn');
            btns.forEach(b => b.classList.remove('active'));

            if (curCat === cat) {
                sub.classList.remove('visible');
                setTimeout(() => sub.style.display = 'none', 200);
                curCat = null;
            } else {
                curCat = cat;
                sub.innerHTML = '';

                if (catalog[cat]) {
                    const itemsContainer = document.createElement('div');
                    itemsContainer.className = 'items-container';

                    let allItems = [];
                    for (let subcategory in catalog[cat]) {
                        allItems = allItems.concat(catalog[cat][subcategory]);
                    }

                    allItems.forEach(item => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'item-image-btn';

                        const img = document.createElement('img');
                        img.src = imageMap[item.id];
                        img.onerror = function () {
                            this.style.display = 'none';
                            itemDiv.innerText = item.name;
                            itemDiv.style.color = 'white';
                            itemDiv.style.fontSize = '12px';
                        };

                        itemDiv.appendChild(img);
                        itemDiv.onclick = (e) => { e.stopPropagation(); spawnItem(item.id); };
                        itemsContainer.appendChild(itemDiv);
                    });
                    sub.appendChild(itemsContainer);
                }

                sub.style.display = 'flex';
                requestAnimationFrame(() => sub.classList.add('visible'));
            }
        }

        function closeMenu() { if (curCat) toggleCat(curCat); }

        function save() { localStorage.setItem('shelter_single_room', JSON.stringify(gameData)); }
        function load() {
            const s = localStorage.getItem('shelter_single_room');
            if (s) {
                gameData = JSON.parse(s);
                // ç¡®ä¿ rooms å­˜åœ¨ (å…¼å®¹æ—§å­˜æ¡£)
                if (!gameData.rooms) gameData.rooms = { "0,0": true };
            }
            // å…¼å®¹æ€§æ¸…æ´—
            if (gameData.floors) { // å¦‚æœæ˜¯æ›´æ—§çš„å­˜æ¡£
                gameData = { items: [], rooms: { "0,0": true } };
            }
        }

        function resetGame() {
            customConfirm("ç¡®å®šè¦é‡ç½®é¿éš¾æ‰€å—ï¼Ÿè¿™å°†æ¸…ç©ºæ‰€æœ‰å®¶å…·å¹¶åªä¿ç•™åˆå§‹æˆ¿é—´ï¼Œä¸”ä¸å¯æ¢å¤ï¼", () => {
                gameData = { items: [], rooms: { "0,0": true } };
                selectedItem = null;
                selectedRoomCoord = null;
                updateDeleteButtonState();
                save();
                showToast("å·²é‡ç½®");
            });
        }

        function customConfirm(msg, onConfirm) {
            const modal = document.getElementById('confirm-modal');
            const msgEl = document.getElementById('modal-msg');
            const confirmBtn = document.getElementById('modal-confirm');
            const cancelBtn = document.getElementById('modal-cancel');

            msgEl.innerText = msg;
            modal.style.display = 'flex';

            confirmBtn.onclick = (e) => {
                e.stopPropagation();
                modal.style.display = 'none';
                if (onConfirm) onConfirm();
            };

            cancelBtn.onclick = (e) => {
                e.stopPropagation();
                modal.style.display = 'none';
            };
        }

        function showToast(m) {
            const t = document.getElementById('toast');
            t.innerText = m;
            t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 1500);
        }

        function updateDeleteButtonState() {
            const deleteBtn = document.getElementById('delete-room-btn');
            if (selectedRoomCoord && isBuildMode) {
                deleteBtn.classList.remove('disabled');
            } else {
                deleteBtn.classList.add('disabled');
            }
        }

        window.addEventListener('resize', resize);
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);

        // æ·»åŠ åº•éƒ¨èœå•çš„è§¦æ‘¸æ»‘åŠ¨æ”¯æŒ
        const mainMenu = document.getElementById('main-menu');
        let isScrolling = false;
        let startX = 0;
        let scrollLeft = 0;

        // è§¦æ‘¸äº‹ä»¶
        mainMenu.addEventListener('touchstart', (e) => {
            isScrolling = true;
            startX = e.touches[0].pageX - mainMenu.offsetLeft;
            scrollLeft = mainMenu.scrollLeft;
        }, { passive: true });

        mainMenu.addEventListener('touchmove', (e) => {
            if (!isScrolling) return;
            e.preventDefault();
            const x = e.touches[0].pageX - mainMenu.offsetLeft;
            const walk = (x - startX) * 2; // æ»šåŠ¨é€Ÿåº¦
            mainMenu.scrollLeft = scrollLeft - walk;
        }, { passive: false });

        mainMenu.addEventListener('touchend', () => {
            isScrolling = false;
        });

        // é¼ æ ‡äº‹ä»¶
        mainMenu.addEventListener('mousedown', (e) => {
            isScrolling = true;
            startX = e.pageX - mainMenu.offsetLeft;
            scrollLeft = mainMenu.scrollLeft;
            mainMenu.style.cursor = 'grabbing'; // æ”¹å˜é¼ æ ‡æ ·å¼
        });

        mainMenu.addEventListener('mousemove', (e) => {
            if (!isScrolling) return;
            e.preventDefault();
            const x = e.pageX - mainMenu.offsetLeft;
            const walk = (x - startX) * 2; // æ»šåŠ¨é€Ÿåº¦
            mainMenu.scrollLeft = scrollLeft - walk;
        });

        mainMenu.addEventListener('mouseup', () => {
            isScrolling = false;
            mainMenu.style.cursor = 'grab'; // æ¢å¤é¼ æ ‡æ ·å¼
        });

        mainMenu.addEventListener('mouseleave', () => {
            isScrolling = false;
            mainMenu.style.cursor = 'grab'; // æ¢å¤é¼ æ ‡æ ·å¼
        });

        // è®¾ç½®åˆå§‹é¼ æ ‡æ ·å¼
        mainMenu.style.cursor = 'grab';

    </script>
</body>

</html>